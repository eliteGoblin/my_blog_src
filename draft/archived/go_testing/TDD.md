

###### general

*  TDD = Refactoring + TFD
*  you instead write your test code before your functional code
*  you do so in very small steps
    -  one test and a small bit of corresponding functional code at a time
    -  refuse to add even a single line of code until a test exists for it
*  two simple rules for TDD
    -  you should write new business code only when an automated test has failed
    -  you should eliminate any duplication that you find
*  Your designs must consist of highly cohesive, loosely coupled components to make testing easier
*  With both traditional testing and TDD you aren't striving for perfection, instead you are testing to the importance of the system
*  If it's worth building, it's worth testing.
*  regression test cases as DOC:
    -  requirements
    -  executable specifications.
    -  not sufficient documentation, but  form an important part of it
*  TDD is very good at detailed specification and validation, but not so good at thinking through bigger issues such as the overall design
    -  建模用:  agile model-driven development (AMDD) 
*  A significant advantage of TDD:
    -  enables you to take small steps, more productive than attempting to code in large steps
*  unit test is more an act of design(and documentation ) than of verification
*  TDD should be seen as complementary to Agile Model Driven Development (AMDD) approaches and the two can and should be used together


###### refs



[Introduction to Test Driven Development](http://agiledata.org/essays/tdd.html)

[TestDrivenDevelopment](https://martinfowler.com/bliki/TestDrivenDevelopment.html)

[The Art of Agile Development: Test-Driven Development](http://www.jamesshore.com/Agile-Book/test_driven_development.html)

[Test driven development book [closed]](https://stackoverflow.com/questions/797026/test-driven-development-book)